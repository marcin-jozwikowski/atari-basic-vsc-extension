{
  "$schema": "https://raw.githubusercontent.com/martinring/tmlanguage/master/tmlanguage.json",
  "name": "Atari BASIC",
  "scopeName": "source.atari.basic",
  "information_for_contributors": [
    "This file is a modified version of https://github.com/thinkyhead/6502-Tools/blob/master/Sublime/AtariTools/AtariBASIC.sublime-syntax"
  ],
  "first_line_match": "\\d+ (\\?|BYE|C(OLOR|L(OSE|OAD|R)|OM|ONT|SAVE)|D(ATA|IM|OS|RAWTO)|EN(TER|D)|FOR|G(ET|O(SUB|TO)|RAPHICS)|IF|INPUT|L(ET|IST|OAD|OCATE|PRINT)|NE(W|XT)|NOTE|ON|OPEN|P(LOT|O(INT|KE|P|SITION)|RINT|UT)|RE(AD|M|STORE|TURN)|RUN|S(AVE|ETCOLOR|OUND|TATUS|TOP)|TRAP)([ :]|$)",
  "patterns": [
    {
      "include": "#main"
    }
  ],
  "repository": {
    "main": {
      "patterns": [
        {
          "comment": "Mark lines that are too long to import",
          "match": "^(.{254})(\\S.+?)\\s*$",
          "captures": {
            "1": {
              "name": "invalid.warning.line-too-long.ataribasic"
            },
            "2": {
              "name": "invalid.error.line-too-long.ataribasic"
            }
          }
        },
        {
          "match": "\\s+"
        },
        {
          "comment": "Existing whole line syntax error",
          "match": "([-+]?(\\d+\\.\\d*(E\\d+)?|\\.?\\d+(E\\d+)?))\\s*ERROR\\s*-.*",
          "name": "invalid.error.line.ataribasic",
          "push": "invalid.illegal"
        },
        {
          "comment": "A code line starting with a number. Float and scientific notation allowed",
          "begin": "[-+]?(\\d+\\.\\d*(E\\d+)?|\\.?\\d+(E\\d+)?)",
          "beginCaptures": {
            "1": {"name": "constant.numeric.line-number.ataribasic"}
          },
          "end": "$",
          "endCaptures": {"1": {"name":"support.token.delimiter.data.ataribasic1"}},
          "patterns": [{"include": "#code_line"}]
        },
        {
          "comment": "A raw code line - without a leading number",
          "begin": "^",
          "end": "$",
          "endCaptures": {"1": {"name":"support.token.delimiter.data.ataribasic2"}},
          "patterns": [{"include": "#code_line"}]
        }
      ]
    },

    "code_line": {
      "patterns": [
        {
          "comment": "REM comment till the end of the line",
          "begin": "(REM|(RE?)?\\.)",
          "end": "$",
          "endCaptures": {"1": {"name":"support.token.delimiter.data.ataribasic3"}},
          "name":"comment.line"
        },
        {
          "comment": "DATA makes the rest of the line a delimited list of strings",
          "begin": "(D(ATA|(AT?)?\\.))\\s*",
          "beginCaptures": {"1": {"name": "keyword.data.ataribasic"}},
          "end": "$",
          "endCaptures": {"1": {"name":"support.token.delimiter.data.ataribasic4"}},
          "patterns": [{"include": "#cmd_data"}]
        },
        {
          "comment": "RESTORE [<nexpr>]",
          "begin": "(RES(TORE|(T(O(RE?)?)?)?\\.))",
          "beginCaptures": {"1":{ "name": "keyword.restore.ataribasic"}},
          "end": "(:|$)",
          "endCaptures": {"1": {"name":"support.token.delimiter.data.ataribasic5"}},
          "patterns": [{"include": "#expr_start"}]
        },
        {
          "comment": "Commands taking no parameters",
          "match": "(CLR)|(CON[T.])|(DEG)|(POP)|(RAD)|(CLOAD)|(CS(AVE|(AV?)?\\.))",
          "captures": {
            "1": {"name": "keyword.clr.ataribasic"},
            "2": {"name": "keyword.cont.ataribasic"},
            "3": {"name": "keyword.deg.ataribasic"},
            "4": {"name": "keyword.pop.ataribasic"},
            "5": {"name": "keyword.rad.ataribasic"},
            "6": {"name": "keyword.cload.ataribasic"},
            "7": {"name": "keyword.csave.ataribasic"}
          }
        },
        {
          "comment": "Commands with no parameters. These should always end the line",
          "begin": "(B(YE|Y?\\.))|(DOS)|(END)|(NEW)|(STO[P.])|(RET(URN|(UR?)?\\.))",
          "beginCaptures": {
            "1": {"name": "keyword.bye.ataribasic"},
            "3": {"name": "keyword.dos.ataribasic"},
            "4": {"name": "keyword.end.ataribasic"},
            "5": {"name": "keyword.new.ataribasic"},
            "6": {"name": "keyword.stop.ataribasic"},
            "7": {"name": "keyword.return.ataribasic"}
          },
          "end": "$",
          "match": "",
          "name": "invalid"
        },
        {
          "begin": "(RU[N.])",
          "beginCaptures": {"1": {"name": "keyword.run.ataribasic"}},
          "end": "$",
          "patterns": [{"include": "#expr_start_last"}]
        }
      ]
    },
    "code_line_todo_and_not_done": {
      "patterns": [
        {
          "match": "(\\?|PR(INT|(IN?)?.))\\s*(#)",
          "captures": {
            "1": "keyword.print.ataribasic",
            "4": "support.token.iocb.ataribasic"
          },
          "push": "cmd_print_dev"
        },
        {
          "match": "\\?|PR(INT|(IN?)?\\.)",
          "scope": "keyword.print.ataribasic",
          "push": "cmd_print"
        },
        {
          "match": "LP(RINT|(R(IN?)?)?\\.)",
          "scope": "keyword.lprint.ataribasic",
          "push": "cmd_print"
        },
        {
          "match": "(I(NPUT|(N(PU?)?)?\\.))\\s*(#)",
          "captures": {
            "1": "keyword.input.ataribasic",
            "5": "support.token.iocb.ataribasic"
          },
          "push": "expr_device"
        },
        {
          "match": "I(NPUT|(N(PU?)?)?\\.)",
          "scope": "keyword.input.ataribasic",
          "push": "expr_start"
        },
        {
          "match": "(CL(OSE|(OS?)?\\.))\\s*(#)",
          "captures": {
            "1": "keyword.close.ataribasic",
            "4": "support.token.iocb.ataribasic"
          },
          "push": "expr_device"
        },
        {
          "match": "(O(PEN|(PE?)?\\.))\\s*(#)",
          "captures": {
            "1": "keyword.open.ataribasic",
            "4": "support.token.iocb.ataribasic"
          },
          "push": "expr_device"
        },
        {
          "match": "((GET)|(NO(TE|T?\\.))|(ST(ATUS|(A(TU?)?)?\\.)))\\s*(#)",
          "captures": {
            "2": "keyword.get.ataribasic",
            "3": "keyword.note.ataribasic",
            "5": "keyword.status.ataribasic",
            "9": "support.token.iocb.ataribasic"
          },
          "push": "expr_device"
        },
        {
          "match": "XIO\\b",
          "scope": "keyword.xio.ataribasic",
          "push": "cmd_xio"
        },
        {
          "match": "(PUT)\\s*(#)",
          "captures": {
            "1": "keyword.get.ataribasic",
            "2": "support.token.iocb.ataribasic"
          },
          "push": "expr_device"
        },
        {
          "match": "(P(OINT|(O(IN?)?)?\\.))\\s*(#)",
          "captures": {
            "1": "keyword.get.ataribasic",
            "5": "support.token.iocb.ataribasic"
          },
          "push": "expr_device"
        },
        {
          "match": "DIM|COM",
          "scope": "keyword.dim.ataribasic",
          "push": "cmd_dim_list"
        },
        {
          "match": "F(OR|O?\\.)",
          "scope": "keyword.for.ataribasic",
          "push": "cmd_for"
        },
        {
          "match": "N(EXT|(EX?)?\\.)",
          "scope": "keyword.next.ataribasic",
          "push": "cmd_next"
        },
        {
          "match": "T(RAP|(RA?)?\\.)",
          "scope": "keyword.trap.ataribasic",
          "push": "one_expr"
        },
        {
          "match": "POK[E.]",
          "scope": "keyword.poke.ataribasic",
          "push": "two_exprs"
        },
        {
          "match": "C(OLOR|(O(LO?)?)?\\.)",
          "scope": "keyword.color.ataribasic",
          "push": "one_expr"
        },
        {
          "match": "DR(AWTO|(A(WT?)?)?\\.)",
          "scope": "keyword.drawto.ataribasic",
          "push": "two_exprs"
        },
        {
          "match": "GR(APHICS|(A(P(H(IC?)?)?)?)?\\.)",
          "scope": "keyword.graphics.ataribasic",
          "push": "one_expr"
        },
        {
          "match": "LOC(ATE|(AT?)?\\.)",
          "scope": "keyword.locate.ataribasic",
          "push": "three_exprs"
        },
        {
          "match": "POS(ITION|(I(T(IO?)?)?)?\\.)",
          "scope": "keyword.position.ataribasic",
          "push": "two_exprs"
        },
        {
          "match": "PL(OT|O?\\.)",
          "scope": "keyword.plot.ataribasic",
          "push": "two_exprs"
        },
        {
          "match": "SE(TCOLOR|(T(C(O(LO?)?)?)?)?\\.)",
          "scope": "keyword.setcolor.ataribasic",
          "push": "three_exprs"
        },
        {
          "match": "SO(UND|(UN?)?\\.)",
          "scope": "keyword.sound.ataribasic",
          "push": "four_exprs"
        },
        {
          "match": "REA[D.]",
          "scope": "keyword.read.ataribasic",
          "push": "expr_start"
        },
        {
          "match": "THREE",
          "scope": "keyword.three.ataribasic",
          "push": "three_exprs"
        },
        {
          "match": "L(IST|(IS?)?\\.)",
          "scope": "keyword.list.ataribasic",
          "push": "expr_start"
        },
        {
          "match": "(LO(AD|A?\\.))|(S(AVE|(AV?)?\\.))|(E(NTER|(N(TE?)?)?\\.))",
          "captures": {
            "1": "keyword.load.ataribasic",
            "3": "keyword.save.ataribasic",
            "6": "keyword.enter.ataribasic"
          },
          "push": "one_expr"
        },
        {
          "match": "G(OTO|(OT?)?\\.)",
          "scope": "keyword.goto.ataribasic",
          "push": "expr_start_last"
        },
        {
          "match": "GOS(UB|U?\\.)",
          "scope": "keyword.gosub.ataribasic",
          "push": "one_expr"
        },
        {
          "match": "ON",
          "scope": "keyword.on.ataribasic",
          "push": "cmd_on"
        },
        {
          "match": "IF",
          "scope": "keyword.if.ataribasic",
          "push": "cmd_if"
        },
        {
          "match": "(LET)?\\s*([A-Z][A-Z0-9]*\\$)",
          "captures": {
            "1": "keyword.let.ataribasic",
            "2": "variable.string.ataribasic"
          },
          "push": "cmd_let"
        },
        {
          "match": "(LET)?\\s*[A-Z][A-Z0-9]*",
          "captures": {
            "1": "keyword.let.ataribasic",
            "2": "variable.float.ataribasic"
          },
          "push": "cmd_let"
        },
        {
          "match": "",
          "name": "invalid.illegal"
        }
      ]
    },

    "cmd_data": {
      "comment": "Data marks the rest of the line as data items: Simple literal strings delimited by commas",
      "patterns": [
        {
          "match": "([^,]+?)(\\s*$)?",
          "name": "entity.literal.string.data.ataribasic"
        },
        {
          "match": "\\,",
          "name": "support.token.delimiter.data.ataribasic6"
        }
      ]
    },
    "cmd_done" : {
      "comment": "A statement known to be completed is marked broken if any tokens follow before a new statement.",
      "patterns": [
        {
          "include": "#mixin_statement_end"
        },
        {
          "match": "",
          "name": "invalid.illegal"
        }
      ]
    },
    "expr_paren_open":{
      "comment": "An expression already within at least one parenthesis.",
      "patterns": [
        {
          "include": "#mixin_containers"
        },
        {
          "include": "#mixin_values"
        },
        {
          "include": "#mixin_operators"
        },
        {
          "match": "[^)]*(;:|$)",
          "name": "invalid.illegal"
        }
      ]
    },
    "expr_start":{
      "comment": "Start a top-level expression",
      "patterns": [
        {
          "include": "#mixin_statement_end"
        },
        {
          "include": "#mixin_top_expr"
        }
      ]
    },
    "expr_start_last": {
      "patterns": [
        {
          "include": "#mixin_top_expr"
        },
        {
          "begin": ":",
          "beginCaptures": {"1":{"name": "support.token.delimiter.statement.ataribasic"}},
          "end": "$",
          "name": "invalid.illegal"
        }
      ]
    },
    "mixin_containers":{
      "comment": "String group and expression group to be used inside parentheses only",
      "patterns": [
        {
          "include": "#mixin_string"
        },
        {
          "begin": "\\(",
          "beginCaptures": {"1": {"name": "support.paren.open.expr.ataribasic"}},
          "end": "\\)",
          "endCaptures": {"1": {"name": "support.paren.close.expr.ataribasic"}},
          "patterns": [{"include": "#expr_paren_open"}]
        }
      ]
    },
    "mixin_operators": {
      "comment": "Grab bag of operators for the dumb expression parser",
      "patterns": [
        {
          "match": "\\,",
          "name": "support.token.delimiter.list.ataribasic"
        },
        {
          "match": "([-+*/^])",
          "name": "keyword.operator.math.ataribasic"
        },
        {
          "match": "(<>|[<>]=?|=|AND|NOT|OR)",
          "name": "keyword.operator.logic.ataribasic"
        }
      ]
    },
    "mixin_statement_end":{
      "comment": "Mix-in to pop the context if the statement ends",
      "patterns": [
        {
          "match": ":\\s*$",
          "name": "invalid.illegal"
        },
        {
          "match": ":|$",
          "name": "support.token.delimiter.statement.ataribasic"
        }
      ]
    },
    "mixin_string" : {
      "comment": "A string opener that pushes quoted_string",
      "patterns": [
        {
          "begin": "\\\"",
          "beginCaptures": {"1":{"name": "punctuation.definition.string.open.ataribasic"}},
          "end": "\\\"",
          "endCaptures": {"1":{"name": "punctuation.definition.string.open.ataribasic"}},
          "patterns": [{"include": "#quoted_string"}],
          "name": "string.quoted.double"
        }
      ]
    },
    "mixin_top_expr":{
      "comment": "For top-level expressions a closing parenthesis breaks the rest of the line",
      "patterns": [
        {
          "include": "#mixin_string"
        },
        {
          "begin": "\\(",
          "beginCaptures": {"1": {"name": "support.paren.open.expr.ataribasic"}},
          "end": "\\)",
          "endCaptures": {"1": {"name": "support.paren.close.expr.ataribasic"}},
          "patterns": [{"include": "#expr_paren_open"}]
        },
        {
          "match": "\\)",
          "name": "invalid.illegal"
        },
        {
          "include": "#mixin_operators"
        },
        {
          "include": "#mixin_values"
        }
      ]
    },
    "mixin_values":{
      "comment": "Rules to match all known value types Always use last so the last reject rule here works",
      "patterns": [
        {
          "match": "[a-z\\$\\%]",
          "name": "invalid.illegal"
        },
        {
          "begin": "CHR\\$",
          "beginCaptures": {"1": {"name": "meta.function-call.chrS.ataribasic"}},
          "end": ":|$",
          "patterns": [{"include": "#required_args"}]
        },
        {
          "begin": "STR\\$",
          "beginCaptures": {"1": {"name": "meta.function-call.str.ataribasic"}},
          "end": ":|$",
          "patterns": [{"include": "#required_args"}]
        },
        {
          "begin": "(FRE)|(USR)|(ABS)|(ADR)|(ASC)|(ATN)|(CLOG)|(COS)|(EXP)|(INT)|(LEN)|(LOG)|(PEEK)|(RND)|(SGN)|(SIN)|(SQR)|(VAL)|(PADDLE)|(PTRIG)|(STICK)|(STRIG)",
          "beginCaptures": {
            "2": {"name":"meta.function-call.usr.ataribasic"},
            "3": {"name":"meta.function-call.abs.ataribasic"},
            "1": {"name":"meta.function-call.fre.ataribasic"},
            "4": {"name":"meta.function-call.adr.ataribasic"},
            "5": {"name":"meta.function-call.asc.ataribasic"},
            "6": {"name":"meta.function-call.atn.ataribasic"},
            "7": {"name":"meta.function-call.clog.ataribasic"},
            "8": {"name":"meta.function-call.cos.ataribasic"},
            "9": {"name":"meta.function-call.exp.ataribasic"},
            "10":{"name": "meta.function-call.int.ataribasic"},
            "11":{"name": "meta.function-call.len.ataribasic"},
            "12":{"name": "meta.function-call.log.ataribasic"},
            "13":{"name": "meta.function-call.peek.ataribasic"},
            "14":{"name": "meta.function-call.rnd.ataribasic"},
            "15":{"name": "meta.function-call.sgn.ataribasic"},
            "16":{"name": "meta.function-call.sin.ataribasic"},
            "17":{"name": "meta.function-call.sqr.ataribasic"},
            "18":{"name": "meta.function-call.val.ataribasic"},
            "19":{"name": "meta.function-call.paddle.ataribasic"},
            "20":{"name": "meta.function-call.ptrig.ataribasic"},
            "21":{"name": "meta.function-call.stick.ataribasic"},
            "22":{"name": "meta.function-call.strig.ataribasic"}
          },
          "end": "\\:|$",
          "patterns": [{"include": "#required_args"}]
        },
        {
          "match": "[-+]?(\\d+\\.\\d*(E\\d+)?|\\.?\\d+(E\\d+)?)",
          "name": "constant.numeric.float.ataribasic"
        },
        {
          "include": "#mixin_variable_name"
        }
      ]
    },
    "mixin_variable_name":{
      "comment": "Rules to match a variable name",
      "patterns": [
        {
          "match": "[A-Z][A-Z0-9]*\\$",
          "captures": {"1" : {"name": "variable.string.ataribasic"}},
          "patterns": [{"include": "#var_eat_subscript"}]
        },
        {
          "match": "[A-Z][A-Z0-9]*",
          "captures": {"1" : {"name": "variable.float.ataribasic"}},
          "patterns": [{"include": "#var_eat_subscript"}]
        }
      ]
    },
    "required_args": {
      "comment": "Function requires parentheses or the line breaks",
      "patterns": [
        {
          "begin": "\\(",
          "beginCaptures": {"1": {"name": "support.paren.open.func.ataribasic"}},
          "end": "\\)",
          "endCaptures": {"1": {"name": "support.paren.close.func.ataribasic"}},
          "patterns": [{"include": "#expr_paren_open"}]
        },
        {
          "match": "",
          "name": "invalid.illegal"
        }
      ]
    },
    "quoted_string":  {
      "comment": "On Atari there's no escaping a string. Strings may legally be quite long, with escape characters in them, etc., by hacking the BASIC language.",
      "patterns": [
        {
          "match": "[^\"]*$",
          "name": "invalid.illegal"
        }
      ]
    },
    "var_eat_subscript":{
      "patterns": [
        {
          "begin": "\\(",
          "beginCaptures": {"1": {"name": "support.paren.open.subscript.ataribasic"}},
          "end": "\\)",
          "endCaptures": {"1": {"name": "support.paren.close.subscript.ataribasic"}},
          "patterns": [{"include": "#expr_paren_open"}]
        }
      ]
    }
  }
}